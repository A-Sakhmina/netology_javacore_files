# netology_javacore_files
I/O streams. Working with files. Serialization, buffering and working with ZIP

В данном репозитории реализовано 3 задачи(**ссылки на код**):
1.  [Задание 1. Установка](https://github.com/A-Sakhmina/netology_javacore_files/tree/master/src/task1_installing)
2.  [Задание 2. Сохранение](https://github.com/A-Sakhmina/netology_javacore_files/tree/master/src/task2_serializing)
3.  [Задание 3. Загрузка](https://github.com/A-Sakhmina/netology_javacore_files/tree/master/src/task3_unZip_unSerializing)

## Задание 1. Установка
Код по [ссылке](https://github.com/A-Sakhmina/netology_javacore_files/tree/master/src/task1_installing)
### Задача 
1.  В папке Games создайте несколько директорий: `src`, `res`, `savegames`, `temp`.
2.  В каталоге src создайте две директории: `main`, `test`.
3.  В подкаталоге main создайте два файла: `Main.java`, `Utils.java`.
4.  В каталог res создайте три директории: `drawables`, `vectors`, `icons`.
5.  В директории temp создайте файл `temp.txt`.
Файл `temp.txt` будет использован для записиси в него информации об успешноном или неуспешном создании файлов и директорий.
### Реализация
Создание директорий осуществлено с помощью метода класса `File` `mkdir()`, который создаёт новую директорию по указанному в качестве аргумента метода пути.

Создание файлов осущественно с использованием метода `createNewFile()`, которому так же передаётся полный путь создаваемого файла. 
Осуществляется создание файла внутри блока `try-catch`, так как метод `createNewFile()` может пробросить исключение, если путь к файлу будет некорректен.

Результат каждой операции заносится в переменную `output` типа `StringBuilder` с помощью метода `apppend()`, в который мы передаём результат. 
Запись в файл данной результирующей строки `output` осуществляется с использованием объекта класса `FileWriter`, 
с помощью методов `write()` и `append()`, определенных в базовом классе `Writer`, производится запись данных. Метод `flush()` дозаписывает буфер и очищает его.
Это всё осуществляется в блоке `try-catch` с ресурсами(в качестве ресурса объект класса `FileWriter` - `writer`, 
конструктору которого передаётся путь(полное наименование файла) для записи и `false` для метода `append()`, чтобы запись в файла шла сначала).

## Задание 2. Сохранение
Код по [ссылке](https://github.com/A-Sakhmina/netology_javacore_files/tree/master/src/task2_serializing)
### Задача 
1.  Создать три экземпляра класса `GameProgress`.
2.  Сохранить сериализованные объекты `GameProgress` в папку `savegames` из предыдущей задачи.
3.  Созданные файлы сохранений из папки `savegames` запаковать в архив zip.
4.  Удалить файлы сохранений, лежащие вне архива.
### Реализация
**Метод** `saveGame()`, принимающий в качестве аргументов полный путь к файлу типа `String` и объект класса `GameProgress`, состояние которого нужно сохранить в файл. 
Для записи используются такие классы как `FileOutputStream` и `ObjectOutputStream`. 
У последнего есть метод `writeObject()`, подходящий для записи сериализованного объекта. Во избежание утечек памяти используется `try` с ресурсами.

Таким образом, вызов метода `saveGame()` приводит к созданию файлов сохранений в папке `savegames`.

**Метод** `zipFiles()`, принимающий в качестве аргументов `String` полный путь к файлу архива и список запаковываемых объектов в виде списка строчек `String` полного пути к файлу. 
В методе реализован блок `try-catch` с объектами `ZipOutputStream` и `FileOutputStream`. 
Внутри него пробегаемся по списку файлов и для каждого организуем запись в блоке `try-catch` через `FileInputStream`. 
Для этого создаётся экземпляр `ZipEntry` и уведомляем `ZipOutputStream` о новом элементе архива с помощью метода `putNextEntry()`. 
Далее считываем упаковываемый файл с помощью метода `read()` и записываем его с помощью метода `write()`. 
После чего уведомляется `ZipOutputStream` о записи файла в архив с помощью метода `closeEntry()`.

Далее, используя методы класса `File`, удаляем файлы сохранений, не лежащие в архиве.
## Задание 3. Загрузка
Код по [ссылке](https://github.com/A-Sakhmina/netology_javacore_files/tree/master/src/task3_unZip_unSerializing)
### Задача 
1.  Произвести распаковку архива в папке savegames.
2.  Произвести считывание и десериализацию одного из разархивированных файлов save.dat.
4.  Вывести в консоль состояние сохранненой игры.
### Реализация
**Метод** `openZip()`, который принимает два аргумента: путь к файлу типа `String` и путь к папке, куда стоит разархивировать файлы типа `String`.

Для распаковки используются такие стримовые классы как `FileInputStream`, `ZipInputStream` и класс объекта архива `ZipEntry`. 
Считывание элементов архива производится с помощью метода `getNextEntry()` класса `ZipInputStream`, а узнаём название объекта `ZipEntry` с помощью метода `getName()`. 
Запись в файл распакованных объектов произведена с помощью `FileOutputStream`.

**Метод** `openProgress()`, который в качестве аргумента принимает путь к файлу с сохраненной игрой типа `String` и возвращает объект типа `GameProgress`. 
В данном методе требуются классы `FileInputStream` и `ObjectInputStream`. 
С помощью метода класса `ObjectInputStream` `readObject()` можно десериализовать объект, а далее привести (скастить) его к `GameProgress`.
